---
title: "MINA 学习（一）"
layout: post
date: 2017-08-07 07:38
image: /assets/images/markdown.jpg
headerImage: false
tag:
- MINA
- client
star: true
category: blog
author: sun
description: Markdown summary with different options
---

## 总结:

Apache Mina Server 是一个网络通信应用框架，也就是说，它主要是对基于TCP/IP、UDP/IP协议栈的通信框架（当然，也可以提供JAVA 对象的序列化服务、虚拟机管道通信服务等），Mina 可以帮助我们快速开发高性能、高扩展性的网络通信应用，Mina 提供了事件驱动、异步（Mina 的异步IO 默认使用的是JAVA NIO 作为底层支持）操作的编程模型。Mina 主要有1.x 和2.x 两个分支，这里我们讲解最新版本2.0，如果你使用的是Mina 1.x，那么可能会有一些功能并不适用。学习本文档，需要你已掌握JAVA IO、JAVA NIO、JAVASocket、JAVA 线程及并发库(java.util.concurrent.*)的知识。Mina 同时提供了网络通信的Server 端、Client 端的封装，无论是哪端，Mina 在整个网通通信结构中都处于如下的位置：可见Mina 的API 将真正的网络通信与我们的应用程序隔离开来，你只需要关心你要发送、接收的数据以及你的业务逻辑即可。同样的，无论是哪端，Mina 的执行流程如下所示：

1. IoService：这个接口在一个线程上负责套接字的建立，拥有自己的Selector，监听是否有连接被建立。
2. IoProcessor：这个接口在另一个线程上，负责检查是否有数据在通道上读写，也就是说它也拥有自己的Selector，这是与我们使用Java NIO 编码时的一个不同之处，通常在java NIO 编码中，我们都是使用一个Selector，也就是不区分IoService与IoProcessor 两个功能接口。另外，IoProcessor 负责调用注册在IoService 上的过滤器，并在过滤器链之后调用IoHandler。
3. IoFilter：这个接口定义一组拦截器，这些拦截器可以包括日志输出、黑名单过滤、数据的编码（write 方向）与解码（read 方向）等功能，其中数据的encode 与decode是最为重要的、也是你在使用Mina 时最主要关注的地方。
4. IoHandler：这个接口负责编写业务逻辑，也就是接收、发送数据的地方。

---

## 简单的TCPServer：

1. 第一步：编写IoService

按照上面的执行流程，我们首先需要编写IoService，IoService 本身既是服务端，又是客户端，我们这里编写服务端，所以使用IoAcceptor 实现，由于IoAcceptor 是与协议无关的，因为我们要编写TCPServer，所以我们使用IoAcceptor 的实现NioSocketAcceptor，实际上底层就是调用Java.nio.channels.ServerSocketChannel 类。当然，如果你使用了Apache 的APR 库，那么你可以选择使AprSocketAcceptor 作为TCPServer 的实现，据传说Apache APR库的性能比JVM 自带的本地库高出很多。那么IoProcessor 是由指定的IoService 内部创建并调用的，我们并不需要关心。

{% highlight java %}
IoAcceptor acceptor=new NioSocketAcceptor();    
acceptor.getSessionConfig().setReadBufferSize(2048);    
acceptor.getSessionConfig.setIdleTime(IdleStatus.BOTH_IDLE,10);    
acceptor.bind(new InetSocketAddress(9123)); 
{% endhighlight %}

这段代码我们初始化了服务端的TCP/IP 的基于NIO 的套接字，然后调用IoSessionConfig设置读取数据的缓冲区大小、读写通道均在10 秒内无任何操作就进入空闲状态。

2. 第二步：编写过滤器

这里我们处理最简单的字符串传输，Mina 已经为我们提供了TextLineCodecFactory 编解码器工厂来对字符串进行编解码处理。

{% highlight java %}
acceptor.getFilterChain().addLast("codec",  new ProtocolCodecFilter(new TextLineCodecFactory(  
Charset.forName("UTF-8"),  
LineDelimiter.WINDOWS.getValue(),
LineDelimiter.WINDOWS.getValue()))  
); 
{% endhighlight %} 

这段代码要在acceptor.bind()方法之前执行，因为绑定套接字之后就不能再做这些准备工作了。这里先不用清楚编解码器是如何工作的，这个是后面重点说明的内容，这里你只需要清楚，我们传输的以换行符为标识的数据，所以使用了Mina 自带的换行符编解码器工厂。

3. 第三步：编写IoHandler

这里我们只是简单的打印Client 传说过来的数据。

{% highlight java %}
public class MyIoHandler extends IoHandlerAdapter {  
// 这里我们使用的SLF4J作为日志门面，至于为什么在后面说明。  
private final static Logger log = LoggerFactory  
.getLogger(MyIoHandler.class);  
@Override  
public void messageReceived(IoSession session, Object message)  
throws Exception {  
String str = message.toString();  
log.info("The message received is [" + str + "]");  
if (str.endsWith("quit")) {  
session.close(true);  
return;  
}  
}  
}   
{% endhighlight %} 

然后我们把这个IoHandler 注册到IoService：

{% highlight java %}
acceptor.setHandler(new MyIoHandler());     
{% endhighlight %} 

当然这段代码也要在acceptor.bind()方法之前执行。然后我们运行MyServer 中的main 方法，你可以看到控制台一直处于阻塞状态，此时，我们用telnet 127.0.0.1 9123 访问，然后输入一些内容，当按下回车键，你会发现数据在Server 端被输出，但要注意不要输入中文，因为Windows 的命令行窗口不会对传输的数据进行UTF-8 编码。当输入quit 结尾的字符串时，连接被断开。这里注意你如果使用的操作系统，或者使用的Telnet 软件的换行符是什么，如果不清楚，可以删掉第二步中的两个红色的参数，使用TextLineCodec 内部的自动识别机制。

---

## 简单的TCPClient：

这里我们实现Mina 中的TCPClient，因为前面说过无论是Server 端还是Client 端，在Mina中的执行流程都是一样的。唯一不同的就是IoService 的Client 端实现是IoConnector。

1. 第一步：编写IoService并注册过滤器

{% highlight java %}
public class MyClient {  
IoConnector connector=new NioSocketConnector();  
connector.setConnectTimeoutMillis(30000);  
connector.getFilterChain().addLast("codec",  
new ProtocolCodecFilter(  
new TextLineCodecFactory(  
Charset.forName("UTF-8"),  
LineDelimiter.WINDOWS.getValue(),  
LineDelimiter.WINDOWS.getValue()  
)  
)  
);  
connector.connect(new InetSocketAddress("localhost", 9123));  
}    
{% endhighlight %} 

2. 第二步：编写IoHandler

{% highlight java %}
public class ClientHandler extends IoHandlerAdapter {    
private final static Logger LOGGER = LoggerFactory    
.getLogger(ClientHandler.class);    
private final String values;    
public ClientHandler(String values) {    
this.values = values;    
}    
@Override    
public void sessionOpened(IoSession session) {    
session.write(values);    
}    
}  
{% endhighlight %} 

3. 第三步：注册IoHandler

{% highlight java %}
connector.setHandler(new ClientHandler("你好！\r\n 大家好！"));   
{% endhighlight %} 

然后我们运行MyClient，你会发现MyServer 输出如下语句：
The message received is [你好！]
The message received is [大家好！]
我们看到服务端是按照收到两条消息输出的，因为我们用的编解码器是以换行符判断数据是否读取完毕的。

---

## 介绍Mina的TCP的主要接口：

通过上面的两个示例，你应该对Mina 如何编写TCP/IP 协议栈的网络通信有了一些感性的认识。

### IoService：

这个接口是服务端IoAcceptor、客户端IoConnector 的抽象，提供IO 服务和管理IoSession的功能，它有如下几个常用的方法：

1. TransportMetadata getTransportMetadata()：
这个方法获取传输方式的元数据描述信息，也就是底层到底基于什么的实现，譬如：nio、apr 等。
2. void addListener(IoServiceListener listener)：
这个方法可以为IoService 增加一个监听器，用于监听IoService 的创建、活动、失效、空闲、销毁，具体可以参考IoServiceListener 接口中的方法，这为你参与IoService 的生命周期提供了机会。
3. void removeListener(IoServiceListener listener)：
这个方法用于移除上面的方法添加的监听器。
4. void setHandler(IoHandler handler)：
这个方法用于向IoService 注册IoHandler，同时有getHandler()方法获取Handler。
5. Map<Long,IoSession> getManagedSessions()：
这个方法获取IoService 上管理的所有IoSession，Map 的key 是IoSession 的id。
6. IoSessionConfig getSessionConfig()：
这个方法用于获取IoSession 的配置对象，通过IoSessionConfig 对象可以设置Socket 连接的一些选项。

---

### IoAcceptor：
这个接口是TCPServer 的接口，主要增加了void bind()监听端口、void unbind()解除对套接字的监听等方法。这里与传统的JAVA 中的ServerSocket 不同的是IoAcceptor 可以多次调用bind()方法（或者在一个方法中传入多个SocketAddress 参数）同时监听多个端口。

---

### IoConnector：
这个接口是TCPClient 的接口， 主要增加了ConnectFuture connect(SocketAddressremoteAddress,SocketAddress localAddress)方法，用于与Server 端建立连接，第二个参数如果不传递则使用本地的一个随机端口访问Server 端。这个方法是异步执行的，同样的，也可以同时连接多个服务端。

---

### IoSession：
这个接口用于表示Server 端与Client 端的连接，IoAcceptor.accept()的时候返回实例。
这个接口有如下常用的方法：
1. WriteFuture write(Object message)：
这个方法用于写数据，该操作是异步的。
2. CloseFuture close(boolean immediately)：
这个方法用于关闭IoSession，该操作也是异步的，参数指定true 表示立即关闭，否则就在所有的写操作都flush 之后再关闭。
3. Object setAttribute(Object key,Object value)：
这个方法用于给我们向会话中添加一些属性，这样可以在会话过程中都可以使用，类似于HttpSession 的setAttrbute()方法。IoSession 内部使用同步的HashMap 存储你添加的自
定义属性。
4. SocketAddress getRemoteAddress()：
这个方法获取远端连接的套接字地址。
5. void suspendWrite()：
这个方法用于挂起写操作，那么有void resumeWrite()方法与之配对。对于read()方法同样适用。
6. ReadFuture read()：
这个方法用于读取数据， 但默认是不能使用的， 你需要调用IoSessionConfig 的setUseReadOperation(true)才可以使用这个异步读取的方法。一般我们不会用到这个方法，因为这个方法的内部实现是将数据保存到一个BlockingQueue，假如是Server 端，因为大量的Client 端发送的数据在Server 端都这么读取，那么可能会导致内存泄漏，但对于Client，可能有的时候会比较便利。
7. IoService getService()：
这个方法返回与当前会话对象关联的IoService 实例。
关于TCP连接的关闭：
无论在客户端还是服务端，IoSession 都用于表示底层的一个TCP 连接，那么你会发现无论是Server 端还是Client 端的IoSession 调用close()方法之后，TCP 连接虽然显示关闭， 但主线程仍然在运行，也就是JVM 并未退出，这是因为IoSession 的close()仅仅是关闭了TCP的连接通道，并没有关闭Server 端、Client 端的程序。你需要调用IoService 的dispose()方法停止Server 端、Client 端。

---

### IoSessionConfig：
这个方法用于指定此次会话的配置，它有如下常用的方法：
1. void setReadBufferSize(int size)：
这个方法设置读取缓冲的字节数，但一般不需要调用这个方法，因为IoProcessor 会自动调整缓冲的大小。你可以调用setMinReadBufferSize()、setMaxReadBufferSize()方法，这样无论IoProcessor 无论如何自动调整，都会在你指定的区间。
2. void setIdleTime(IdleStatus status,int idleTime)：
这个方法设置关联在通道上的读、写或者是读写事件在指定时间内未发生，该通道就进入空闲状态。一旦调用这个方法，则每隔idleTime 都会回调过滤器、IoHandler 中的sessionIdle()方法。
3. void setWriteTimeout(int time)：
这个方法设置写操作的超时时间。
4. void setUseReadOperation(boolean useReadOperation)：
这个方法设置IoSession 的read()方法是否可用，默认是false。

---

### IoHandler:

* A named link to [Mark It Down][3].
* Another named link to [Mark It Down](http://markitdown.net/)
* Sometimes you just want a URL like <http://markitdown.net/>.

{% highlight raw %}
* A named link to [MarkItDown][3].
* Another named link to [MarkItDown](http://markitdown.net/)
* Sometimes you just want a URL like <http://markitdown.net/>.
{% endhighlight %}

---

### Comum Elements
- [Basic formatting](#basic-formatting)
- [Headings](#headings)
- [Lists](#lists)
- [Paragraph Modifiers](#paragraph-modifiers)
- [Urls](#urls)
- [Horizontal Rule](#horizontal-rule)
- [Images](#images)
- [Code](#code)

---

## 多路分离的解码器：

假设一段数据发送过来之后，需要根据某种条件决定使用哪个解码器，而不是像上面的例子，固定使用一个解码器，那么该如何做呢？幸好Mina 提供了org.apache.mina.filter.codec.demux 包来完成这种多路分离（Demultiplexes）的解码工作，也就是同时注册多个解码器，然后运行时依据传入的数据决定到底使用哪个解码器来工作。所谓多路分离就是依据条件分发到指定的解码器，譬如：上面的短信协议进行扩展，可以依据状态行来判断使用1.0 版本的短信协议解码器还是2.0版本的短信协议解码器。

下面我们使用一个简单的例子，说明这个多路分离的解码器是如何使用的，需求如下所示：

1. 客户端传入两个int 类型的数字，还有一个char 类型的符号。
2. 如果符号是+，服务端就是用1 号解码器，对两个数字相加，然后把结果返回给客户端。
3. 如果符号是-，服务端就使用2 号解码器，将两个数字变为相反数，然后相加，把结果返回给客户端。

{% highlight html %}
This note **demonstrates** some of what [Markdown][some/link] is *capable of doing*.
{% endhighlight %}

---

## Headings

There are six levels of headings. They correspond with the six levels of HTML headings. You've probably noticed them already in the page. Each level down uses one more hash character. But we are using just 4 of them.

# Headings can be small

## Headings can be small

### Headings can be small

#### Headings can be small

{% highlight raw %}
# Heading
## Heading
### Heading
#### Heading
{% endhighlight %}

---

## Lists

### Ordered list

1. Item 1
2. A second item
3. Number 3

{% highlight raw %}
1. Item 1
2. A second item
3. Number 3
{% endhighlight %}

### Unordered list

* An item
* Another item
* Yet another item
* And there's more...

{% highlight raw %}
* An item
* Another item
* Yet another item
* And there's more...
{% endhighlight %}

---

## Paragraph modifiers

### Quote

> Here is a quote. What this is should be self explanatory. Quotes are automatically indented when they are used.

{% highlight raw %}
> Here is a quote. What this is should be self explanatory.
{% endhighlight raw %}

---

## URLs

URLs can be made in a handful of ways:

* A named link to [Mark It Down][3].
* Another named link to [Mark It Down](http://markitdown.net/)
* Sometimes you just want a URL like <http://markitdown.net/>.

{% highlight raw %}
* A named link to [MarkItDown][3].
* Another named link to [MarkItDown](http://markitdown.net/)
* Sometimes you just want a URL like <http://markitdown.net/>.
{% endhighlight %}

---

## Horizontal rule

A horizontal rule is a line that goes across the middle of the page.
It's sometimes handy for breaking things up.

{% highlight raw %}
---
{% endhighlight %}

---

## Images

Markdown can also contain images. I'll need to add something here sometime.

{% highlight raw %}
![Markdowm Image][/image/url]
{% endhighlight %}

![Markdowm Image][6]

*Figure Caption*?

{% highlight raw %}
![Markdowm Image][/image/url]
<figcaption class="caption">Photo by John Doe</figcaption>
{% endhighlight %}

![Markdowm Image][6]
<figcaption class="caption">Photo by John Doe</figcaption>

*Bigger Images*?

{% highlight raw %}
![Markdowm Image][/image/url]{: class="bigger-image" }
{% endhighlight %}

![Markdowm Image][6]{: class="bigger-image" }

---

## Code

A HTML Example:

{% highlight html %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    <h1>Just a test</h1>
</body>
</html>
{% endhighlight %}

A CSS Example:

{% highlight css %}
pre {
    padding: 10px;
    font-size: .8em;
    white-space: pre;
}

pre, table {
    width: 100%;
}

code, pre, tt {
    font-family: Monaco, Consolas, Inconsolata, monospace, sans-serif;
    background: rgba(0,0,0,.05);
}
{% endhighlight %}

A JS Example:

{% highlight js %}
// Sticky Header
$(window).scroll(function() {

    if ($(window).scrollTop() > 900 && !$("body").hasClass('show-menu')) {
        $('#hamburguer__open').fadeOut('fast');
    } else if (!$("body").hasClass('show-menu')) {
        $('#hamburguer__open').fadeIn('fast');
    }

});
{% endhighlight %}

[1]: http://daringfireball.net/projects/markdown/
[2]: http://www.fileformat.info/info/unicode/char/2163/index.htm
[3]: http://www.markitdown.net/
[4]: http://daringfireball.net/projects/markdown/basics
[5]: http://daringfireball.net/projects/markdown/syntax
[6]: http://kune.fr/wp-content/uploads/2013/10/ghost-blog.jpg

http://blog.csdn.net/w13770269691/article/details/8614584
http://blog.csdn.net/c1481118216/article/details/52826250
http://www.cnblogs.com/zzt-lovelinlin/p/5292608.html
